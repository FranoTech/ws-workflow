/* soapClient.cpp
   Generated by gSOAP 2.8.8 from ImageTransformations.h

Copyright(C) 2000-2012, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif
#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapClient.cpp ver 2.8.8 2012-09-19 07:43:51 GMT")


SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__Threshold(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string InputMatFilename, double thresholdValue, double maxValue, std::string thresholdType, std::string &OutputMatFilename)
{	struct ns__Threshold soap_tmp_ns__Threshold;
	struct ns__ThresholdResponse *soap_tmp_ns__ThresholdResponse;
	if (!soap_endpoint)
		soap_endpoint = "http://localhost/cgi-bin/ImageTransformationsServer";
	soap->encodingStyle = "";
	soap_tmp_ns__Threshold.InputMatFilename = InputMatFilename;
	soap_tmp_ns__Threshold.thresholdValue = thresholdValue;
	soap_tmp_ns__Threshold.maxValue = maxValue;
	soap_tmp_ns__Threshold.thresholdType = thresholdType;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_ns__Threshold(soap, &soap_tmp_ns__Threshold);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__Threshold(soap, &soap_tmp_ns__Threshold, "ns:Threshold", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__Threshold(soap, &soap_tmp_ns__Threshold, "ns:Threshold", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&OutputMatFilename)
		return soap_closesock(soap);
	soap_default_std__string(soap, &OutputMatFilename);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__ThresholdResponse = soap_get_ns__ThresholdResponse(soap, NULL, "", "");
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	OutputMatFilename = soap_tmp_ns__ThresholdResponse->OutputMatFilename;
	return soap_closesock(soap);
}

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__cvtColor(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string InputMatFilename, std::string code, int dstChannel_D, std::string &OutputMatFilename)
{	struct ns__cvtColor soap_tmp_ns__cvtColor;
	struct ns__cvtColorResponse *soap_tmp_ns__cvtColorResponse;
	if (!soap_endpoint)
		soap_endpoint = "http://localhost/cgi-bin/ImageTransformationsServer";
	soap->encodingStyle = "";
	soap_tmp_ns__cvtColor.InputMatFilename = InputMatFilename;
	soap_tmp_ns__cvtColor.code = code;
	soap_tmp_ns__cvtColor.dstChannel_D = dstChannel_D;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_ns__cvtColor(soap, &soap_tmp_ns__cvtColor);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__cvtColor(soap, &soap_tmp_ns__cvtColor, "ns:cvtColor", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__cvtColor(soap, &soap_tmp_ns__cvtColor, "ns:cvtColor", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&OutputMatFilename)
		return soap_closesock(soap);
	soap_default_std__string(soap, &OutputMatFilename);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__cvtColorResponse = soap_get_ns__cvtColorResponse(soap, NULL, "", "");
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	OutputMatFilename = soap_tmp_ns__cvtColorResponse->OutputMatFilename;
	return soap_closesock(soap);
}

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__integral(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string InputMatFilename, int sdepth_D, std::string &OutputMatFilename)
{	struct ns__integral soap_tmp_ns__integral;
	struct ns__integralResponse *soap_tmp_ns__integralResponse;
	if (!soap_endpoint)
		soap_endpoint = "http://localhost/cgi-bin/ImageTransformationsServer";
	soap->encodingStyle = "";
	soap_tmp_ns__integral.InputMatFilename = InputMatFilename;
	soap_tmp_ns__integral.sdepth_D = sdepth_D;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_ns__integral(soap, &soap_tmp_ns__integral);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__integral(soap, &soap_tmp_ns__integral, "ns:integral", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__integral(soap, &soap_tmp_ns__integral, "ns:integral", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&OutputMatFilename)
		return soap_closesock(soap);
	soap_default_std__string(soap, &OutputMatFilename);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__integralResponse = soap_get_ns__integralResponse(soap, NULL, "", "");
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	OutputMatFilename = soap_tmp_ns__integralResponse->OutputMatFilename;
	return soap_closesock(soap);
}

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__adaptiveThreshold(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string InputMatFilename, std::string adaptiveMethod, double maxValue, std::string thresholdType, int blockSize, double C, std::string &OutputMatFilename)
{	struct ns__adaptiveThreshold soap_tmp_ns__adaptiveThreshold;
	struct ns__adaptiveThresholdResponse *soap_tmp_ns__adaptiveThresholdResponse;
	if (!soap_endpoint)
		soap_endpoint = "http://localhost/cgi-bin/ImageTransformationsServer";
	soap->encodingStyle = "";
	soap_tmp_ns__adaptiveThreshold.InputMatFilename = InputMatFilename;
	soap_tmp_ns__adaptiveThreshold.adaptiveMethod = adaptiveMethod;
	soap_tmp_ns__adaptiveThreshold.maxValue = maxValue;
	soap_tmp_ns__adaptiveThreshold.thresholdType = thresholdType;
	soap_tmp_ns__adaptiveThreshold.blockSize = blockSize;
	soap_tmp_ns__adaptiveThreshold.C = C;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_ns__adaptiveThreshold(soap, &soap_tmp_ns__adaptiveThreshold);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__adaptiveThreshold(soap, &soap_tmp_ns__adaptiveThreshold, "ns:adaptiveThreshold", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__adaptiveThreshold(soap, &soap_tmp_ns__adaptiveThreshold, "ns:adaptiveThreshold", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&OutputMatFilename)
		return soap_closesock(soap);
	soap_default_std__string(soap, &OutputMatFilename);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__adaptiveThresholdResponse = soap_get_ns__adaptiveThresholdResponse(soap, NULL, "", "");
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	OutputMatFilename = soap_tmp_ns__adaptiveThresholdResponse->OutputMatFilename;
	return soap_closesock(soap);
}

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__adjustBrighnessAndContrast(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string InputMatFilename, double alpha, int beta, std::string &OutputMatFilename)
{	struct ns__adjustBrighnessAndContrast soap_tmp_ns__adjustBrighnessAndContrast;
	struct ns__adjustBrighnessAndContrastResponse *soap_tmp_ns__adjustBrighnessAndContrastResponse;
	if (!soap_endpoint)
		soap_endpoint = "http://localhost/cgi-bin/ImageTransformationsServer";
	soap->encodingStyle = "";
	soap_tmp_ns__adjustBrighnessAndContrast.InputMatFilename = InputMatFilename;
	soap_tmp_ns__adjustBrighnessAndContrast.alpha = alpha;
	soap_tmp_ns__adjustBrighnessAndContrast.beta = beta;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_ns__adjustBrighnessAndContrast(soap, &soap_tmp_ns__adjustBrighnessAndContrast);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__adjustBrighnessAndContrast(soap, &soap_tmp_ns__adjustBrighnessAndContrast, "ns:adjustBrighnessAndContrast", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__adjustBrighnessAndContrast(soap, &soap_tmp_ns__adjustBrighnessAndContrast, "ns:adjustBrighnessAndContrast", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&OutputMatFilename)
		return soap_closesock(soap);
	soap_default_std__string(soap, &OutputMatFilename);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__adjustBrighnessAndContrastResponse = soap_get_ns__adjustBrighnessAndContrastResponse(soap, NULL, "", "");
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	OutputMatFilename = soap_tmp_ns__adjustBrighnessAndContrastResponse->OutputMatFilename;
	return soap_closesock(soap);
}

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__watershed(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string InputMatFilename, std::string MarkerMatFilename, std::string &OutputMatFilename)
{	struct ns__watershed soap_tmp_ns__watershed;
	struct ns__watershedResponse *soap_tmp_ns__watershedResponse;
	if (!soap_endpoint)
		soap_endpoint = "http://localhost/cgi-bin/ImageTransformationsServer";
	soap->encodingStyle = "";
	soap_tmp_ns__watershed.InputMatFilename = InputMatFilename;
	soap_tmp_ns__watershed.MarkerMatFilename = MarkerMatFilename;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_ns__watershed(soap, &soap_tmp_ns__watershed);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__watershed(soap, &soap_tmp_ns__watershed, "ns:watershed", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_endpoint, soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__watershed(soap, &soap_tmp_ns__watershed, "ns:watershed", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&OutputMatFilename)
		return soap_closesock(soap);
	soap_default_std__string(soap, &OutputMatFilename);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__watershedResponse = soap_get_ns__watershedResponse(soap, NULL, "", "");
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	OutputMatFilename = soap_tmp_ns__watershedResponse->OutputMatFilename;
	return soap_closesock(soap);
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapClient.cpp */
